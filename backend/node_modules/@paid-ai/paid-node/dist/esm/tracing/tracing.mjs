var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SpanStatusCode } from "@opentelemetry/api";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { NodeTracerProvider, SimpleSpanProcessor } from "@opentelemetry/sdk-trace-node";
import winston from "winston";
import { runWithTracingContext } from "./tracingContext.mjs";
import { PaidSpanProcessor } from "./spanProcessor.mjs";
export const logger = winston.createLogger({
    level: "silent", // Default to 'silent' to avoid logging unless set via environment variable
    format: winston.format.simple(),
    transports: [new winston.transports.Console()],
});
const logLevel = process.env.PAID_LOG_LEVEL;
if (logLevel) {
    logger.level = logLevel;
}
const DEFAULT_COLLECTOR_ENDPOINT = process.env["PAID_OTEL_COLLECTOR_ENDPOINT"] || "https://collector.agentpaid.io:4318/v1/traces";
let paidApiToken = undefined;
export function getToken() {
    return paidApiToken;
}
let paidTracerProvider = undefined;
export function getPaidTracerProvider() {
    return paidTracerProvider;
}
let paidTracer = undefined;
export function getPaidTracer() {
    return paidTracer;
}
let _isShuttingDown = false;
const setupGracefulShutdown = (shuttable) => {
    ["SIGINT", "SIGTERM", "beforeExit", "uncaughtException", "unhandledRejection"].forEach((signal) => {
        process.on(signal, () => {
            if (_isShuttingDown) {
                return;
            }
            _isShuttingDown = true;
            shuttable
                .shutdown()
                .then(() => logger.info(`Paid tracing SDK shut down from signal: ${signal}`))
                .catch((error) => logger.error(`Error shutting down Paid tracing SDK ${error}`));
        });
    });
};
export function initializeTracing(apiKey, collectorEndpoint) {
    const paidEnabled = (process.env.PAID_ENABLED || "true") !== "false";
    if (!paidEnabled) {
        logger.info("Paid tracing is disabled via PAID_ENABLED environment variable");
        return;
    }
    const token = getToken();
    if (!!token) {
        logger.info("Tracing is already initialized - skipping re-intialization");
        return;
    }
    if (!apiKey) {
        const envKey = process.env.PAID_API_KEY;
        if (!envKey) {
            logger.error("API key must be provided via PAID_API_KEY environment variable");
            return;
        }
        paidApiToken = envKey;
    }
    else {
        paidApiToken = apiKey;
    }
    const url = collectorEndpoint || DEFAULT_COLLECTOR_ENDPOINT;
    const exporter = new OTLPTraceExporter({ url });
    const spanProcessor = new SimpleSpanProcessor(exporter);
    paidTracerProvider = new NodeTracerProvider({
        spanProcessors: [spanProcessor, new PaidSpanProcessor()],
    });
    paidTracerProvider.register();
    paidTracer = paidTracerProvider.getTracer("paid.node");
    setupGracefulShutdown(spanProcessor);
    logger.info(`Paid tracing SDK initialized with collector endpoint: ${url}`);
}
export function trace(options, fn, ...args) {
    return __awaiter(this, void 0, void 0, function* () {
        const token = getToken();
        const tracer = getPaidTracer();
        if (!token || !tracer) {
            throw new Error("Paid tracing is not initialized. Make sure to call initializeTracing() first.");
        }
        const { externalCustomerId, externalProductId: externalAgentId, storePrompt, metadata } = options;
        return yield tracer.startActiveSpan("parent_span", (span) => __awaiter(this, void 0, void 0, function* () {
            span.setAttribute("external_customer_id", externalCustomerId);
            span.setAttribute("token", token);
            if (externalAgentId) {
                span.setAttribute("external_agent_id", externalAgentId);
            }
            try {
                const res = yield runWithTracingContext({
                    externalCustomerId,
                    externalProductId: externalAgentId,
                    storePrompt,
                    metadata,
                }, () => __awaiter(this, void 0, void 0, function* () { return yield fn(...args); }));
                span.setStatus({ code: SpanStatusCode.OK });
                return res;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: error.message,
                });
                span.recordException(error);
                throw error;
            }
            finally {
                span.end();
            }
        }));
    });
}
