var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SpanStatusCode } from "@opentelemetry/api";
import { getPaidTracer, getToken } from "tracing/tracing.js";
import { getTracingContext } from "tracing/tracingContext.js";
export class PaidMistral {
    constructor(mistralClient) {
        this.mistral = mistralClient;
        const tracer = getPaidTracer();
        if (!tracer) {
            throw new Error("Paid tracer is not initialized, Make sure to call 'initializeTracing()' first");
        }
        this.tracer = tracer;
    }
    get ocr() {
        return new OCRWrapper(this.mistral, this.tracer);
    }
}
class OCRWrapper {
    constructor(mistral, tracer) {
        this.mistral = mistral;
        this.tracer = tracer;
    }
    process(request, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = getToken();
            const { externalProductId, externalCustomerId } = getTracingContext();
            if (!token || !externalCustomerId) {
                throw new Error("No token or externalCustomerId: This wrapper should be used inside a callback to paid.trace().");
            }
            return this.tracer.startActiveSpan("trace.mistral.ocr", (span) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const attributes = {
                    "gen_ai.system": "mistral",
                    "gen_ai.operation.name": "ocr",
                    external_customer_id: externalCustomerId,
                    token: token,
                };
                if (externalProductId) {
                    attributes["external_agent_id"] = externalProductId;
                }
                // Check if annotations are requested
                if (request.bboxAnnotationFormat || request.documentAnnotationFormat) {
                    attributes["gen_ai.ocr.annotated"] = "true";
                }
                // Set request model
                if (request.model) {
                    attributes["gen_ai.request.model"] = request.model;
                }
                span.setAttributes(attributes);
                try {
                    const response = yield this.mistral.ocr.process(request, options);
                    // Add usage information from response
                    if (((_a = response.usageInfo) === null || _a === void 0 ? void 0 : _a.pagesProcessed) !== undefined) {
                        span.setAttribute("gen_ai.ocr.pages_processed", response.usageInfo.pagesProcessed);
                    }
                    if (response.model) {
                        span.setAttribute("gen_ai.response.model", response.model);
                    }
                    span.setStatus({ code: SpanStatusCode.OK });
                    return response;
                }
                catch (error) {
                    span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
                    span.recordException(error);
                    throw error;
                }
                finally {
                    span.end();
                }
            }));
        });
    }
}
