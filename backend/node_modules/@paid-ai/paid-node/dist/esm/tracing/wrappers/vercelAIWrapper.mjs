var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SpanStatusCode } from "@opentelemetry/api";
import { generateText as originalGenerateText, streamText as originalStreamText, generateObject as originalGenerateObject, streamObject as originalStreamObject, embed as originalEmbed, embedMany as originalEmbedMany, } from "ai";
import { getPaidTracer, getToken } from "tracing/tracing.js";
import { getTracingContext } from "tracing/tracingContext.js";
function getModelInfo(model) {
    if (model === null || model === void 0 ? void 0 : model.modelId) {
        const modelId = model.modelId;
        if (modelId.startsWith("gpt-") || modelId.startsWith("text-embedding-") || modelId.startsWith("dall-e-")) {
            return { system: "openai", modelName: modelId };
        }
        if (modelId.startsWith("claude-")) {
            return { system: "anthropic", modelName: modelId };
        }
        if (modelId.startsWith("mistral-") || modelId.startsWith("codestral-")) {
            return { system: "mistral", modelName: modelId };
        }
        if (modelId.includes("gemini")) {
            return { system: "google", modelName: modelId };
        }
    }
    if (model === null || model === void 0 ? void 0 : model.provider) {
        return { system: model.provider, modelName: model.modelId };
    }
    return { system: "unknown" };
}
function extractUsageMetrics(usage) {
    const usageAttrs = {};
    const inputTokens = usage.promptTokens || usage.prompt_tokens || usage.inputTokens;
    const outputTokens = usage.completionTokens || usage.completion_tokens || usage.outputTokens;
    const cachedTokens = usage.cachedPromptTokens || usage.cached_prompt_tokens || usage.cachedInputTokens;
    if (inputTokens !== undefined) {
        usageAttrs["gen_ai.usage.input_tokens"] = inputTokens;
    }
    if (outputTokens !== undefined) {
        usageAttrs["gen_ai.usage.output_tokens"] = outputTokens;
    }
    if (cachedTokens !== undefined) {
        usageAttrs["gen_ai.usage.cached_input_tokens"] = cachedTokens;
    }
    if (usage.tokens !== undefined && inputTokens === undefined) {
        usageAttrs["gen_ai.usage.input_tokens"] = usage.tokens;
    }
    return usageAttrs;
}
function validateContext() {
    const token = getToken();
    const { externalCustomerId, externalProductId } = getTracingContext();
    if (!token || !externalCustomerId) {
        throw new Error("No token or externalCustomerId: This wrapper should be used inside a callback to paid.trace().");
    }
    return {
        externalCustomerId,
        externalProductId,
        token,
    };
}
export function generateText(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const context = validateContext();
        const { system: aiSystem, modelName } = getModelInfo(params.model);
        const tracer = getPaidTracer();
        if (!tracer) {
            throw new Error("Paid tracer is not initialized, Make sure to call 'initializeTracing()' first");
        }
        return tracer.startActiveSpan("trace.ai-sdk.generateText", (span) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const attributes = {
                "gen_ai.system": aiSystem,
                "gen_ai.operation.name": "chat",
                external_customer_id: context.externalCustomerId,
                token: context.token,
            };
            if (context.externalProductId) {
                attributes["external_agent_id"] = context.externalProductId;
            }
            if (modelName) {
                attributes["gen_ai.request.model"] = modelName;
            }
            span.setAttributes(attributes);
            try {
                const result = yield originalGenerateText(params);
                if (result.usage) {
                    const usageAttrs = extractUsageMetrics(result.usage);
                    span.setAttributes(usageAttrs);
                }
                if ((_a = result.response) === null || _a === void 0 ? void 0 : _a.modelId) {
                    span.setAttribute("gen_ai.response.model", result.response.modelId);
                }
                span.setStatus({ code: SpanStatusCode.OK });
                return result;
            }
            catch (error) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
                span.recordException(error);
                throw error;
            }
            finally {
                span.end();
            }
        }));
    });
}
export function streamText(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const context = validateContext();
        const { system: aiSystem, modelName } = getModelInfo(params.model);
        const tracer = getPaidTracer();
        if (!tracer) {
            throw new Error("Paid tracer is not initialized, Make sure to call 'initializeTracing()' first");
        }
        return tracer.startActiveSpan("trace.ai-sdk.streamText", (span) => __awaiter(this, void 0, void 0, function* () {
            const attributes = {
                "gen_ai.system": aiSystem,
                "gen_ai.operation.name": "chat",
                external_customer_id: context.externalCustomerId,
                token: context.token,
            };
            if (context.externalProductId) {
                attributes["external_agent_id"] = context.externalProductId;
            }
            if (modelName) {
                attributes["gen_ai.request.model"] = modelName;
            }
            span.setAttributes(attributes);
            try {
                const originalOnFinish = params.onFinish;
                const wrappedParams = Object.assign(Object.assign({}, params), { onFinish: (result) => {
                        if (result.usage) {
                            const usageAttrs = extractUsageMetrics(result.usage);
                            span.setAttributes(usageAttrs);
                        }
                        if (originalOnFinish) {
                            originalOnFinish(result);
                        }
                        span.setStatus({ code: SpanStatusCode.OK });
                        span.end();
                    } });
                const result = originalStreamText(wrappedParams);
                return result;
            }
            catch (error) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
                span.recordException(error);
                throw error;
            }
            finally {
                span.end();
            }
        }));
    });
}
export function generateObject(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const context = validateContext();
        const { system: aiSystem, modelName } = getModelInfo(params.model);
        const tracer = getPaidTracer();
        if (!tracer) {
            throw new Error("Paid tracer is not initialized, Make sure to call 'initializeTracing()' first");
        }
        return tracer.startActiveSpan("trace.ai-sdk.generateObject", (span) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const attributes = {
                "gen_ai.system": aiSystem,
                "gen_ai.operation.name": "chat",
                external_customer_id: context.externalCustomerId,
                token: context.token,
            };
            if (context.externalProductId) {
                attributes["external_agent_id"] = context.externalProductId;
            }
            if (modelName) {
                attributes["gen_ai.request.model"] = modelName;
            }
            span.setAttributes(attributes);
            try {
                const result = yield originalGenerateObject(params);
                if (result.usage) {
                    const usageAttrs = extractUsageMetrics(result.usage);
                    span.setAttributes(usageAttrs);
                }
                if ((_a = result.response) === null || _a === void 0 ? void 0 : _a.modelId) {
                    span.setAttribute("gen_ai.response.model", result.response.modelId);
                }
                span.setStatus({ code: SpanStatusCode.OK });
                return result;
            }
            catch (error) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
                span.recordException(error);
                throw error;
            }
            finally {
                span.end();
            }
        }));
    });
}
export function streamObject(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const context = validateContext();
        const { system: aiSystem, modelName } = getModelInfo(params.model);
        const tracer = getPaidTracer();
        if (!tracer) {
            throw new Error("Paid tracer is not initialized, Make sure to call 'initializeTracing()' first");
        }
        return tracer.startActiveSpan("trace.ai-sdk.streamObject", (span) => __awaiter(this, void 0, void 0, function* () {
            const attributes = {
                "gen_ai.system": aiSystem,
                "gen_ai.operation.name": "chat",
                external_customer_id: context.externalCustomerId,
                token: context.token,
            };
            if (context.externalProductId) {
                attributes["external_agent_id"] = context.externalProductId;
            }
            if (modelName) {
                attributes["gen_ai.request.model"] = modelName;
            }
            span.setAttributes(attributes);
            try {
                const originalOnFinish = params.onFinish;
                const wrappedParams = Object.assign(Object.assign({}, params), { onFinish: (result) => {
                        if (result.usage) {
                            const usageAttrs = extractUsageMetrics(result.usage);
                            span.setAttributes(usageAttrs);
                        }
                        if (originalOnFinish) {
                            originalOnFinish(result);
                        }
                        span.setStatus({ code: SpanStatusCode.OK });
                        span.end();
                    } });
                const result = originalStreamObject(wrappedParams);
                return result;
            }
            catch (error) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
                span.recordException(error);
                throw error;
            }
        }));
    });
}
export function embed(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const context = validateContext();
        const { system: aiSystem, modelName } = getModelInfo(params.model);
        const tracer = getPaidTracer();
        if (!tracer) {
            throw new Error("Paid tracer is not initialized, Make sure to call 'initializeTracing()' first");
        }
        return tracer.startActiveSpan("trace.ai-sdk.embed", (span) => __awaiter(this, void 0, void 0, function* () {
            const attributes = {
                "gen_ai.system": aiSystem,
                "gen_ai.operation.name": "embeddings",
                external_customer_id: context.externalCustomerId,
                token: context.token,
            };
            if (context.externalProductId) {
                attributes["external_agent_id"] = context.externalProductId;
            }
            if (modelName) {
                attributes["gen_ai.request.model"] = modelName;
            }
            span.setAttributes(attributes);
            try {
                const result = yield originalEmbed(params);
                if (result.usage) {
                    const usageAttrs = extractUsageMetrics(result.usage);
                    span.setAttributes(usageAttrs);
                }
                span.setStatus({ code: SpanStatusCode.OK });
                return result;
            }
            catch (error) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
                span.recordException(error);
                throw error;
            }
            finally {
                span.end();
            }
        }));
    });
}
export function embedMany(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const context = validateContext();
        const { system: aiSystem, modelName } = getModelInfo(params.model);
        const tracer = getPaidTracer();
        if (!tracer) {
            throw new Error("Paid tracer is not initialized, Make sure to call 'initializeTracing()' first");
        }
        return tracer.startActiveSpan("trace.ai-sdk.embedMany", (span) => __awaiter(this, void 0, void 0, function* () {
            const attributes = {
                "gen_ai.system": aiSystem,
                "gen_ai.operation.name": "embeddings",
                external_customer_id: context.externalCustomerId,
                token: context.token,
            };
            if (context.externalProductId) {
                attributes["external_agent_id"] = context.externalProductId;
            }
            if (modelName) {
                attributes["gen_ai.request.model"] = modelName;
            }
            span.setAttributes(attributes);
            try {
                const result = yield originalEmbedMany(params);
                if (result.usage) {
                    const usageAttrs = extractUsageMetrics(result.usage);
                    span.setAttributes(usageAttrs);
                }
                span.setStatus({ code: SpanStatusCode.OK });
                return result;
            }
            catch (error) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
                span.recordException(error);
                throw error;
            }
            finally {
                span.end();
            }
        }));
    });
}
export default {
    generateText,
    streamText,
    generateObject,
    streamObject,
    embed,
    embedMany,
};
