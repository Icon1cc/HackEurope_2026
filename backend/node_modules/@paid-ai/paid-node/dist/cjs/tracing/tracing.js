"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = void 0;
exports.getToken = getToken;
exports.getPaidTracerProvider = getPaidTracerProvider;
exports.getPaidTracer = getPaidTracer;
exports.initializeTracing = initializeTracing;
exports.trace = trace;
const api_1 = require("@opentelemetry/api");
const exporter_trace_otlp_http_1 = require("@opentelemetry/exporter-trace-otlp-http");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const winston_1 = __importDefault(require("winston"));
const tracingContext_js_1 = require("./tracingContext.js");
const spanProcessor_js_1 = require("./spanProcessor.js");
exports.logger = winston_1.default.createLogger({
    level: "silent", // Default to 'silent' to avoid logging unless set via environment variable
    format: winston_1.default.format.simple(),
    transports: [new winston_1.default.transports.Console()],
});
const logLevel = process.env.PAID_LOG_LEVEL;
if (logLevel) {
    exports.logger.level = logLevel;
}
const DEFAULT_COLLECTOR_ENDPOINT = process.env["PAID_OTEL_COLLECTOR_ENDPOINT"] || "https://collector.agentpaid.io:4318/v1/traces";
let paidApiToken = undefined;
function getToken() {
    return paidApiToken;
}
let paidTracerProvider = undefined;
function getPaidTracerProvider() {
    return paidTracerProvider;
}
let paidTracer = undefined;
function getPaidTracer() {
    return paidTracer;
}
let _isShuttingDown = false;
const setupGracefulShutdown = (shuttable) => {
    ["SIGINT", "SIGTERM", "beforeExit", "uncaughtException", "unhandledRejection"].forEach((signal) => {
        process.on(signal, () => {
            if (_isShuttingDown) {
                return;
            }
            _isShuttingDown = true;
            shuttable
                .shutdown()
                .then(() => exports.logger.info(`Paid tracing SDK shut down from signal: ${signal}`))
                .catch((error) => exports.logger.error(`Error shutting down Paid tracing SDK ${error}`));
        });
    });
};
function initializeTracing(apiKey, collectorEndpoint) {
    const paidEnabled = (process.env.PAID_ENABLED || "true") !== "false";
    if (!paidEnabled) {
        exports.logger.info("Paid tracing is disabled via PAID_ENABLED environment variable");
        return;
    }
    const token = getToken();
    if (!!token) {
        exports.logger.info("Tracing is already initialized - skipping re-intialization");
        return;
    }
    if (!apiKey) {
        const envKey = process.env.PAID_API_KEY;
        if (!envKey) {
            exports.logger.error("API key must be provided via PAID_API_KEY environment variable");
            return;
        }
        paidApiToken = envKey;
    }
    else {
        paidApiToken = apiKey;
    }
    const url = collectorEndpoint || DEFAULT_COLLECTOR_ENDPOINT;
    const exporter = new exporter_trace_otlp_http_1.OTLPTraceExporter({ url });
    const spanProcessor = new sdk_trace_node_1.SimpleSpanProcessor(exporter);
    paidTracerProvider = new sdk_trace_node_1.NodeTracerProvider({
        spanProcessors: [spanProcessor, new spanProcessor_js_1.PaidSpanProcessor()],
    });
    paidTracerProvider.register();
    paidTracer = paidTracerProvider.getTracer("paid.node");
    setupGracefulShutdown(spanProcessor);
    exports.logger.info(`Paid tracing SDK initialized with collector endpoint: ${url}`);
}
function trace(options, fn, ...args) {
    return __awaiter(this, void 0, void 0, function* () {
        const token = getToken();
        const tracer = getPaidTracer();
        if (!token || !tracer) {
            throw new Error("Paid tracing is not initialized. Make sure to call initializeTracing() first.");
        }
        const { externalCustomerId, externalProductId: externalAgentId, storePrompt, metadata } = options;
        return yield tracer.startActiveSpan("parent_span", (span) => __awaiter(this, void 0, void 0, function* () {
            span.setAttribute("external_customer_id", externalCustomerId);
            span.setAttribute("token", token);
            if (externalAgentId) {
                span.setAttribute("external_agent_id", externalAgentId);
            }
            try {
                const res = yield (0, tracingContext_js_1.runWithTracingContext)({
                    externalCustomerId,
                    externalProductId: externalAgentId,
                    storePrompt,
                    metadata,
                }, () => __awaiter(this, void 0, void 0, function* () { return yield fn(...args); }));
                span.setStatus({ code: api_1.SpanStatusCode.OK });
                return res;
            }
            catch (error) {
                span.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message: error.message,
                });
                span.recordException(error);
                throw error;
            }
            finally {
                span.end();
            }
        }));
    });
}
