"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaidSpanProcessor = void 0;
const tracingContext_js_1 = require("./tracingContext.js");
const tracing_js_1 = require("./tracing.js");
class PaidSpanProcessor {
    onStart(span, _parentContext) {
        const { name } = span;
        const { storePrompt, externalCustomerId, externalProductId: externalAgentId } = (0, tracingContext_js_1.getTracingContext)();
        if (!storePrompt) {
            const originalSetAttribute = span.setAttribute;
            span.setAttribute = function (key, value) {
                const isPromptRelated = PaidSpanProcessor.PROMPT_ATTRIBUTES_SUBSTRINGS.some((substr) => key.includes(substr));
                if (isPromptRelated)
                    return this;
                return originalSetAttribute.call(this, key, value);
            };
            const originalSetAttributes = span.setAttributes;
            span.setAttributes = function (attributes) {
                const newAttributes = Object.entries(attributes).reduce((acc, [key, value]) => {
                    const isPromptRelated = PaidSpanProcessor.PROMPT_ATTRIBUTES_SUBSTRINGS.some((substr) => key.includes(substr));
                    if (isPromptRelated)
                        return acc;
                    return Object.assign(Object.assign({}, acc), { [key]: value });
                }, {});
                return originalSetAttributes.call(this, newAttributes);
            };
        }
        if (name && !name.startsWith(PaidSpanProcessor.SPAN_NAME_PREFIX)) {
            span.updateName(`${PaidSpanProcessor.SPAN_NAME_PREFIX}${name}`);
        }
        if (externalCustomerId) {
            span.setAttribute("external_customer_id", externalCustomerId);
        }
        if (externalAgentId) {
            span.setAttribute("external_agent_id", externalAgentId);
        }
        const token = (0, tracing_js_1.getToken)();
        if (token) {
            span.setAttribute("token", token);
        }
    }
    onEnd() {
        // mutating this span object doesn't do anything
        // so we achieve filtering within the onStart method by monkey patching
        // setAttribute method
        return;
    }
    shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    forceFlush() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
}
exports.PaidSpanProcessor = PaidSpanProcessor;
PaidSpanProcessor.SPAN_NAME_PREFIX = "paid.trace.";
PaidSpanProcessor.PROMPT_ATTRIBUTES_SUBSTRINGS = [
    "gen_ai.completion",
    "gen_ai.request.messages",
    "gen_ai.response.messages",
    "llm.output_message",
    "llm.input_message",
    "llm.invocation_parameters",
    "gen_ai.prompt",
    "langchain.prompt",
    "output.value",
    "input.value",
];
