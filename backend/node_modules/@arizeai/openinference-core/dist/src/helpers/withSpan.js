"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withSpan = withSpan;
const openinference_semantic_conventions_1 = require("@arizeai/openinference-semantic-conventions");
const api_1 = require("@opentelemetry/api");
const typeUtils_1 = require("../utils/typeUtils");
const attributeHelpers_1 = require("./attributeHelpers");
const tracerHelpers_1 = require("./tracerHelpers");
const { OPENINFERENCE_SPAN_KIND } = openinference_semantic_conventions_1.SemanticConventions;
/**
 * Wraps a function with openinference tracing capabilities, creating spans for execution monitoring.
 *
 * This function provides comprehensive tracing for both synchronous and asynchronous functions,
 * automatically handling span lifecycle, input/output processing, error tracking, and promise
 * resolution.
 *
 * @experimental This API is experimental and may change in future versions
 *
 * @template Fn - The function type being wrapped, preserving original signature
 * @param fn - The function to wrap with tracing capabilities
 * @param options - Configuration options for tracing behavior
 * @param options.tracer - Custom OpenTelemetry tracer instance (defaults to global tracer)
 * @param options.name - Custom span name (defaults to function name)
 * @param options.openTelemetrySpanKind - OpenTelemetry span kind (defaults to INTERNAL)
 * @param options.kind - OpenInference span kind for semantic categorization (defaults to CHAIN)
 * @param options.processInput - Custom function to process input arguments into attributes
 * @param options.processOutput - Custom function to process output values into attributes
 * @param options.attributes - Base attributes to be added to every span created
 *
 * @returns A wrapped function with identical signature that creates spans during execution
 *
 * @example
 * ```typescript
 * // Basic function wrapping
 * const add = (a: number, b: number) => a + b;
 * const tracedAdd = withSpan(add);
 * const result = tracedAdd(2, 3); // Creates a span named "add"
 *
 * // Async function with custom options
 * const fetchData = async (url: string) => {
 *   const response = await fetch(url);
 *   return response.json();
 * };
 * const tracedFetch = withSpan(fetchData, {
 *   name: "api-request",
 *   kind: OpenInferenceSpanKind.LLM
 * });
 *
 * // Custom input/output processing with base attributes
 * const processUser = (user: User) => ({ ...user, processed: true });
 * const tracedProcess = withSpan(processUser, {
 *   attributes: {
 *     'service.name': 'user-processor',
 *     'service.version': '1.0.0'
 *   },
 *   processInput: (user) => ({ "user.id": user.id }),
 *   processOutput: (result) => ({ "result.processed": result.processed })
 * });
 * ```
 */
function withSpan(fn, options) {
    const { tracer: _tracer, name: optionsName, processInput: _processInput, processOutput: _processOutput, openTelemetrySpanKind = api_1.SpanKind.INTERNAL, kind = openinference_semantic_conventions_1.OpenInferenceSpanKind.CHAIN, attributes: baseAttributes, } = options || {};
    const tracer = _tracer ? (0, tracerHelpers_1.wrapTracer)(_tracer) : (0, tracerHelpers_1.getTracer)();
    const processInput = _processInput !== null && _processInput !== void 0 ? _processInput : attributeHelpers_1.defaultProcessInput;
    const processOutput = _processOutput !== null && _processOutput !== void 0 ? _processOutput : attributeHelpers_1.defaultProcessOutput;
    const spanName = optionsName || fn.name;
    // TODO: infer the name from the target
    const wrappedFn = function (...args) {
        return tracer.startActiveSpan(spanName, {
            kind: openTelemetrySpanKind,
            attributes: Object.assign(Object.assign(Object.assign({}, baseAttributes), { [OPENINFERENCE_SPAN_KIND]: kind }), processInput(...args)),
        }, (span) => {
            const result = fn(...args);
            if ((0, typeUtils_1.isPromise)(result)) {
                // Execute the promise and return the promise chain
                return result
                    .then((value) => {
                    span.setAttributes(Object.assign({}, processOutput(value)));
                    span.setStatus({
                        code: api_1.SpanStatusCode.OK,
                    });
                    return value;
                })
                    .catch((e) => {
                    var _a;
                    span.recordException(e);
                    span.setStatus({
                        code: api_1.SpanStatusCode.ERROR,
                        message: String((_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : e),
                    });
                    throw e;
                })
                    .finally(() => span.end());
            }
            else {
                // It is a normal function
                span.setAttributes(Object.assign({}, processOutput(result)));
                span.setStatus({
                    code: api_1.SpanStatusCode.OK,
                });
                span.end();
                return result;
            }
        });
    };
    return wrappedFn;
}
//# sourceMappingURL=withSpan.js.map